/*
객체지향프로그래밍(OOP)

캡슐화, 추상화, 다형성, 상속성

캡슐화)

캡슐화 : 하나의 객채가 특정한 목적을 위하여 변수를 하나로 묶는것 >> 정보의 은닉화

2000만원이 어떠한 사람이 접근 하느냐에 따라 0원이 될 수 있음

getter, setter  메소드를 통해서만 간접적으로 접근



추상화)

클레스 안에 최소한의 공통 요소나 필수 요소를 넣었으면 하는 바램에서 만들어진 것

추상적으로 끄집어낸 개념들을 클레스로 생성


다형성)
같은 동작이지만 다른 결과물 --> 다형성

오버라이딩 : 상위클레스에서 만들어진 메서드를 다시 재창조해서 사용하는 것
오버로딩 : 같은 이름의 메서드를 사용하지만 각 메서드마다 다른용도로 사용 , 결과물도 다르게 구현


상속성, 재사용)
기존 상위클레스에 근거하여 새롭게 클레스와 행위를 정의
기존 클레스의 기능 제사용 + 새롭게 만든 클레스에 새로운 기능 추가

c++ 에서는 다중상속이 지원

상수맴버변수 --> 한번초기화되면 그 값을 변경할 수 없는 맴버변수 const 로 선언
상수맴버함수 --> 호출한 객체의 데이터를 변경할 수 없는 맴버함수, 함수의 원형 마지막에  const 선언

파생클레스

--> 상속
사용자에게 높은 수준의 코드 재활용성 제공

--> 클래스 상속
기존에 정의되어 있는 클래스의 모든 맴버변수와 맴버함수를 받아 새로운 클레스 작성
상속을 통하여 새롭게 작성되는 클레스 --> 파생클레스, 자식클레스, 하위클레스

기존에 작성된 클레스 재활용 가능

--> 파생클래스
기초클레스의 모든 특성을 물려받아 작성된 클레스
접근제어지사자 생략 --> 파생클레스의 접근제어 권한은  private 으로 설정


가상함수
파생클레스에서 재정의할 것으로 기대되는 맴버함수
virtual 키워드를 사용하여 선언 --> 파생클레스에서 재정의된 맴버함수도 자동으로 가상함수가 됨
프로그램이 실행될때 객체를 결정
동적바인딩, 지연바인딩 --> 런타임에 올바른 함수가 실행될 수 있도록 해주는 작업


--> 동적바인딩
어느블록에 있는 함수를 실행하라는 의미로 해석하는 것
가상함수가 아닌 맴버함수는 모드 정적바인딩


가상함수테이블
C++컴파일러 --> 각각의 객체마다 가상함수테이블을 가르키는 포인터를 지정하기 위한 숨겨진 맴버를 하나씩 추가 --> 가상함수를 단 하나라도 가지는 클레스에 대하여 가상함수테이블 작성
--> 가상함수의 주소가 저장됨(해당클레스의 객체들을 위해 선언된 가상함수들의 주소)


가상소멸자
--> 기초클레스의 소멸자는 반드시 가상소멸자료 선언해야 함

맴버함수오버라이딩
 --> 함수 오버로딩 : 서로 다른 시그니쳐를 갖는 어려 함수를 같은 이름으로 정의
 --> 함수 오버라이딩 : 이미 정의된 함수의 무시, 같은 이름의 함수를 새롭게 정의

 오버라이딩 >> 멤버함수의 동작만의 제정의, 함수의 원형은 기존 멤버함수의 원형과 동일해야 함

"->" : 맴버접근연산자

맴버함수를 가상으로 선언 --> 포인터가 실제로 가리키는 객체에 다라 호출대상 변경 가능


추상클레스
  --> 가상함수는 재정의가 가능한 함수를 가리킴

순수가상함수 --> 파생클레스에서 반드시 재정의 해야하는 맴버함수를 의미, 함수의 옹작을 정의하는 본체가 없음.

=0 --> 함수만 있고 본체는 없다


추상클레스
  --> 하나 이상의 순수 가상함수를 포함하는 클래스
  --> 다형성을 가진 함수의 집합을 정의할 수 있게 해줌
  --> 동작이 정의되지 않은 순수 가상함수를 포함하고 있으므로 인스턴스 생성 불가

  














*/

